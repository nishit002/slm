"""
AI CURRICULUM GENERATOR
========================

A Streamlit application for generating comprehensive academic study materials
using AI (Grok API) and compiling them into professionally formatted PDFs.

SETUP REQUIREMENTS:
------------------
1. Install required packages:
   pip install streamlit requests

2. System Requirements:
   - pdflatex (Install MiKTeX on Windows or MacTeX on macOS)
   - Ensure pdflatex is in your system PATH

3. API Configuration:
   - Enter your Grok API key in the configuration page
   - Default key is pre-filled

USAGE:
------
Run: streamlit run app.py
"""

import streamlit as st
import requests
import json
import subprocess
import time
import os
import re
from datetime import datetime

# --- Configuration ---
DEFAULT_API_KEY = "xai-6QJwG3u6540lVZyXbFBArvLQ43ZyJsrnq65pyCWhxh5zXqNvtwe6LdTURbTwvE2sA3Uxlb9gn82Vamgu"
API_URL = "https://api.x.ai/v1/chat/completions"

# --- LaTeX Template ---
LATEX_TEMPLATE = r"""
\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{tocbibind}
\usepackage{titlesec}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}

% Page geometry
\geometry{a4paper, margin=1in}

% Hyperlink setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Academic Study Material},
    pdfpagemode=FullScreen,
}

% Header and Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\nouppercase{\leftmark}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Chapter and Section Styling
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries\color{black}}
  {UNIT \thechapter}{10pt}{\huge\bfseries}
\titlespacing*{\chapter}{0pt}{-30pt}{40pt}

\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}

\begin{document}

\title{
    \vspace{-4cm}
    \fontsize{24pt}{28pt}\selectfont \textbf{%(course_title)s} \\
    \vspace{1cm}
    \fontsize{16pt}{20pt}\selectfont Academic Study Material
}
\author{Generated by AI Curriculum Generator}
\date{\today}
\maketitle

\tableofcontents
\clearpage

%(content)s

\end{document}
"""

# --- Helper Functions ---

def get_api_headers():
    """Get API headers with current API key from session state."""
    api_key = st.session_state.get('api_key', DEFAULT_API_KEY)
    return {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }

def make_api_call(messages, retries=3, delay=5):
    """Makes a call to the Grok API with retry logic and timeout handling."""
    headers = get_api_headers()
    
    payload = {
        "messages": messages,
        "model": "grok-4-latest",
        "stream": False,
        "temperature": 0.3
    }
    
    for attempt in range(retries):
        try:
            response = requests.post(
                API_URL, 
                headers=headers, 
                json=payload, 
                timeout=300  # 5 minute timeout
            )
            response.raise_for_status()
            return response.json()['choices'][0]['message']['content']
        except requests.exceptions.Timeout:
            st.warning(f"‚è±Ô∏è Request timed out (Attempt {attempt + 1}/{retries}). Retrying...")
            time.sleep(delay)
        except requests.exceptions.RequestException as e:
            st.warning(f"‚ö†Ô∏è API call failed (Attempt {attempt + 1}/{retries}): {e}")
            time.sleep(delay)
    
    st.error("‚ùå API call failed after multiple retries. Please check your API key and try again.")
    return None

def escape_latex(text):
    """Escapes special LaTeX characters."""
    if not text:
        return ""
    
    text = str(text)
    # Order matters for backslash
    text = re.sub(r'\\', r'\\textbackslash{}', text)
    text = re.sub(r'([{}_#%&$])', r'\\\1', text)
    text = re.sub(r'~', r'\\textasciitilde{}', text)
    text = re.sub(r'\^', r'\\textasciicircum{}', text)
    return text

def markdown_to_latex(md_text):
    """Converts markdown content to LaTeX formatting."""
    if not md_text:
        return ""
    
    # Custom block for 'Check Your Progress'
    md_text = re.sub(
        r'---\s*CHECK YOUR PROGRESS\s*---(.*?)---+', 
        r'\\begin{center}\\rule{0.8\\textwidth}{0.4pt}\\end{center}\n\\textbf{Check Your Progress}\n\\begin{enumerate}\1\\end{enumerate}\n\\begin{center}\\rule{0.8\\textwidth}{0.4pt}\\end{center}',
        md_text, 
        flags=re.DOTALL | re.IGNORECASE
    )
    
    # Headers
    md_text = re.sub(r'^# UNIT (\d+):\s*(.*?)$', r'\\chapter{\2}', md_text, flags=re.MULTILINE)
    md_text = re.sub(r'^##\s*(\d+\.\d+)\s+(.*?)$', r'\\section{\2}', md_text, flags=re.MULTILINE)
    md_text = re.sub(r'^###\s+(.*?)$', r'\\subsection{\1}', md_text, flags=re.MULTILINE)
    
    # Bold and Italic
    md_text = re.sub(r'\*\*(.*?)\*\*', r'\\textbf{\1}', md_text)
    md_text = re.sub(r'\*(.*?)\*', r'\\textit{\1}', md_text)
    md_text = re.sub(r'_(.*?)_', r'\\textit{\1}', md_text)
    
    # Bullet points - convert to itemize environment
    lines = md_text.split('\n')
    result = []
    in_list = False
    
    for line in lines:
        if re.match(r'^\s*[-*]\s+', line):
            if not in_list:
                result.append('\\begin{itemize}')
                in_list = True
            item_text = re.sub(r'^\s*[-*]\s+', '', line)
            result.append(f'\\item {item_text}')
        else:
            if in_list:
                result.append('\\end{itemize}')
                in_list = False
            result.append(line)
    
    if in_list:
        result.append('\\end{itemize}')
    
    md_text = '\n'.join(result)
    
    # Numbered lists
    md_text = re.sub(r'^\d+\.\s+(.*?)$', r'\\item \1', md_text, flags=re.MULTILINE)
    
    return escape_latex(md_text)

def compile_pdf(course_title, content_dict, outline):
    """Assembles content and compiles it into a PDF using pdflatex."""
    st.info("üìù Assembling document content...")
    
    full_content_md = ""
    
    for unit in outline:
        unit_num = unit.get('unit_number', 1)
        unit_title = unit.get('unit_title', 'Untitled Unit')
        
        full_content_md += f"# UNIT {unit_num}: {unit_title}\n\n"
        
        for section in unit.get('sections', []):
            section_num = section.get('section_number', '1.1')
            section_title = section.get('section_title', 'Untitled Section')
            section_key = f"{section_num} {section_title}"
            
            full_content_md += f"## {section_key}\n\n"
            content = content_dict.get(section_key, "Content not generated.")
            full_content_md += f"{content}\n\n"
    
    st.info("üîÑ Converting content to LaTeX format...")
    latex_content = markdown_to_latex(full_content_md)
    
    final_latex_doc = LATEX_TEMPLATE % {
        'course_title': escape_latex(course_title),
        'content': latex_content
    }
    
    # Generate filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"curriculum_{timestamp}"
    
    with open(f"{filename}.tex", "w", encoding='utf-8') as f:
        f.write(final_latex_doc)
    
    st.info("‚öôÔ∏è Compiling PDF with pdflatex... This may take a moment.")
    
    try:
        # Run pdflatex twice for proper cross-references
        result1 = subprocess.run(
            ['pdflatex', '-interaction=nonstopmode', f'{filename}.tex'],
            check=True,
            capture_output=True,
            timeout=120
        )
        
        result2 = subprocess.run(
            ['pdflatex', '-interaction=nonstopmode', f'{filename}.tex'],
            check=True,
            capture_output=True,
            timeout=120
        )
        
        st.success("‚úÖ PDF compiled successfully!")
        return f"{filename}.pdf"
        
    except subprocess.TimeoutExpired:
        st.error("‚è±Ô∏è PDF compilation timed out. The document may be too large.")
        return None
    except subprocess.CalledProcessError as e:
        st.error("‚ùå PDF Compilation Failed. Ensure 'pdflatex' is installed and in your PATH.")
        st.error(f"Error details: {e}")
        with st.expander("View compilation log"):
            st.code(e.stdout.decode('utf-8', errors='ignore'), language='log')
        return None
    except FileNotFoundError:
        st.error("‚ùå pdflatex not found. Please install MiKTeX or MacTeX.")
        return None

# --- Streamlit UI Functions ---

def show_configuration_page():
    """Step 1: Configure course parameters."""
    st.header("üìã Step 1: Configure Your Course")
    
    # API Key Configuration
    st.subheader("üîë API Configuration")
    col1, col2 = st.columns([3, 1])
    with col1:
        api_key_input = st.text_input(
            "Grok API Key",
            value=st.session_state.get('api_key', DEFAULT_API_KEY),
            type="password",
            help="Enter your Grok API key. Default key is pre-filled.",
            key="api_key_input"
        )
        st.session_state.api_key = api_key_input
    with col2:
        if st.button("üß™ Test API", use_container_width=True):
            with st.spinner("Testing API connection..."):
                test_messages = [{"role": "user", "content": "Say 'API is working!' and nothing else"}]
                response = make_api_call(test_messages)
                if response:
                    st.success("‚úÖ API working!")
                else:
                    st.error("‚ùå API test failed")
    
    st.divider()
    
    # Course Configuration
    st.subheader("üìö Course Details")
    
    st.text_input(
        "Course Title",
        "Organisational Behaviour: Concept, Nature & Historical Perspectives",
        key="course_title",
        help="Enter the full title of your course"
    )
    
    st.selectbox(
        "Target Audience",
        ["Postgraduate (MBA)", "University Undergraduate", "Professional Development"],
        key="target_audience",
        help="Select the primary audience for this course"
    )
    
    st.text_area(
        "Learning Objectives / Course Scope",
        "Develop comprehensive, topic-wise textual content for a 3-credit MBA course. "
        "The content should be academically rigorous, apply Bloom's Taxonomy, and adhere "
        "to a standard academic unit structure, including sections for introduction, "
        "objectives, main content, case studies, and 'Check Your Progress' questions.",
        key="learning_objectives",
        height=200,
        help="Describe the key learning objectives and scope of the course"
    )
    
    st.divider()
    
    col1, col2 = st.columns([1, 3])
    with col1:
        if st.button("üöÄ Generate Course Outline", type="primary", use_container_width=True):
            if not st.session_state.get('api_key'):
                st.error("‚ùå Please enter an API key first!")
            else:
                st.session_state.step = "outline_generation"
                st.rerun()

def show_outline_page():
    """Step 2: Generate and approve course outline."""
    st.header("üéØ Step 2: Review and Approve the Course Outline")
    
    if 'outline' not in st.session_state:
        with st.spinner("ü§ñ Generating a detailed course outline using AI..."):
            system_prompt = """You are an expert instructional designer for postgraduate MBA programs, creating a course structure suitable for a detailed academic study guide.

Your output MUST be a valid JSON array with the following structure:

[
  {
    "unit_number": 1,
    "unit_title": "Title of Unit",
    "sections": [
      {"section_number": "1.1", "section_title": "Introduction", "description": "Brief overview..."},
      {"section_number": "1.2", "section_title": "Objectives", "description": "Learning outcomes..."},
      {"section_number": "1.3", "section_title": "Main Topic 1", "description": "Detailed concepts..."},
      {"section_number": "1.4", "section_title": "Main Topic 2", "description": "Detailed concepts..."},
      {"section_number": "1.5", "section_title": "Let Us Sum Up", "description": "Summary points..."},
      {"section_number": "1.6", "section_title": "Unit End Activities", "description": "Questions and exercises..."}
    ]
  }
]

CRITICAL REQUIREMENTS:
1. Create 4-6 units total
2. Each unit MUST have 6-10 sections
3. First two sections: "Introduction" and "Objectives"
4. Middle sections (3-8): Substantive content topics with detailed descriptions
5. Last two sections: "Let Us Sum Up" and "Unit End Activities"
6. Section numbering: Use format "X.Y" where X is unit number, Y is section number
7. Each description should be 1-2 sentences explaining what will be covered

Output ONLY the JSON array, no markdown formatting, no explanations."""

            user_prompt = f"""Course Title: {st.session_state.course_title}
Target Audience: {st.session_state.target_audience}
Learning Objectives: {st.session_state.learning_objectives}

Generate a comprehensive course outline following the exact JSON structure specified."""

            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
            
            outline_str = make_api_call(messages)
            
            if outline_str:
                try:
                    # Extract JSON from code blocks if present
                    json_match = re.search(r'```(?:json)?\s*\n(.*?)\n```', outline_str, re.DOTALL)
                    if json_match:
                        outline_str = json_match.group(1)
                    
                    # Clean up the string
                    outline_str = outline_str.strip()
                    
                    st.session_state.outline = json.loads(outline_str)
                    st.success("‚úÖ Outline generated successfully!")
                    
                except json.JSONDecodeError as e:
                    st.error(f"‚ùå Failed to parse outline. JSON Error: {e}")
                    with st.expander("View raw response"):
                        st.code(outline_str)
                    
                    # Provide a default structure
                    st.warning("Using default outline structure. Please edit as needed.")
                    st.session_state.outline = [
                        {
                            "unit_number": 1,
                            "unit_title": "Introduction to the Subject",
                            "sections": [
                                {"section_number": "1.1", "section_title": "Introduction", "description": "Overview of the unit"},
                                {"section_number": "1.2", "section_title": "Objectives", "description": "Learning outcomes"},
                                {"section_number": "1.3", "section_title": "Main Concepts", "description": "Core concepts and definitions"},
                                {"section_number": "1.4", "section_title": "Let Us Sum Up", "description": "Summary of key points"},
                                {"section_number": "1.5", "section_title": "Unit End Activities", "description": "Review questions"}
                            ]
                        }
                    ]
            else:
                st.error("‚ùå Could not generate an outline from the API.")
                if st.button("‚Üê Back to Configuration"):
                    st.session_state.step = "configuration"
                    st.rerun()
                return
    
    if 'outline' in st.session_state:
        st.info("üìù Review the generated outline. You can edit it directly before proceeding. Add/remove units or sections as needed.")
        
        # Convert outline to a flat table format for editing
        outline_rows = []
        for unit in st.session_state.outline:
            unit_num = unit.get('unit_number', 1)
            unit_title = unit.get('unit_title', '')
            
            for section in unit.get('sections', []):
                outline_rows.append({
                    'unit_number': unit_num,
                    'unit_title': unit_title,
                    'section_number': section.get('section_number', ''),
                    'section_title': section.get('section_title', ''),
                    'description': section.get('description', '')
                })
        
        # Create editable dataframe
        edited_df = st.data_editor(
            outline_rows,
            num_rows="dynamic",
            use_container_width=True,
            height=500,
            column_config={
                "unit_number": st.column_config.NumberColumn(
                    "Unit No.",
                    help="Unit number",
                    width="small",
                    required=True
                ),
                "unit_title": st.column_config.TextColumn(
                    "Unit Title",
                    help="Title of the unit",
                    width="medium",
                    required=True
                ),
                "section_number": st.column_config.TextColumn(
                    "Section No.",
                    help="Section number (e.g., 1.1, 1.2)",
                    width="small",
                    required=True
                ),
                "section_title": st.column_config.TextColumn(
                    "Section Title",
                    help="Title of the section",
                    width="medium",
                    required=True
                ),
                "description": st.column_config.TextColumn(
                    "Description",
                    help="What will be covered in this section",
                    width="large",
                    required=True
                )
            }
        )
        
        # Show statistics
        col1, col2, col3 = st.columns(3)
        with col1:
            num_units = len(set(row['unit_number'] for row in edited_df))
            st.metric("Total Units", num_units)
        with col2:
            st.metric("Total Sections", len(edited_df))
        with col3:
            avg_sections = len(edited_df) / num_units if num_units > 0 else 0
            st.metric("Avg Sections/Unit", f"{avg_sections:.1f}")
        
        st.divider()
        
        col1, col2, col3 = st.columns([1, 1, 2])
        with col1:
            if st.button("‚úÖ Approve Outline & Begin Writing", type="primary", use_container_width=True):
                # Convert edited dataframe back to outline structure
                approved_outline = []
                current_unit = None
                
                for row in edited_df:
                    unit_num = row['unit_number']
                    
                    # Check if we need to start a new unit
                    if current_unit is None or current_unit['unit_number'] != unit_num:
                        if current_unit is not None:
                            approved_outline.append(current_unit)
                        
                        current_unit = {
                            'unit_number': unit_num,
                            'unit_title': row['unit_title'],
                            'sections': []
                        }
                    
                    # Add section to current unit
                    current_unit['sections'].append({
                        'section_number': row['section_number'],
                        'section_title': row['section_title'],
                        'description': row['description']
                    })
                
                # Don't forget the last unit
                if current_unit is not None:
                    approved_outline.append(current_unit)
                
                st.session_state.approved_outline = approved_outline
                st.session_state.step = "content_generation"
                st.rerun()
        
        with col2:
            if st.button("‚Üê Back to Configuration", use_container_width=True):
                del st.session_state.outline
                st.session_state.step = "configuration"
                st.rerun()
        
        with col3:
            st.caption("üí° Tip: You can add rows, delete rows, or modify any field in the table above.")

def show_content_generation_page():
    """Step 3: Generate content for each section."""
    st.header("‚úçÔ∏è Step 3: Content Generation in Progress")
    
    # Initialize content generation state
    if 'content' not in st.session_state:
        st.session_state.content = {}
        st.session_state.sections_to_process = []
        
        for unit in st.session_state.approved_outline:
            for section in unit.get('sections', []):
                st.session_state.sections_to_process.append({
                    "unit_number": unit['unit_number'],
                    "unit_title": unit['unit_title'],
                    "section_number": section['section_number'],
                    "section_title": section['section_title'],
                    "description": section.get('description', '')
                })
    
    total_sections = len(st.session_state.sections_to_process)
    completed_sections = len(st.session_state.content)
    
    # Progress bar
    progress_percentage = completed_sections / total_sections if total_sections > 0 else 0
    st.progress(
        progress_percentage,
        text=f"Overall Progress: {completed_sections}/{total_sections} Sections Generated"
    )
    
    # Generate content for remaining sections
    if completed_sections < total_sections:
        current_section = st.session_state.sections_to_process[completed_sections]
        unit_title = current_section['unit_title']
        section_number = current_section['section_number']
        section_title = current_section['section_title']
        description = current_section['description']
        section_key = f"{section_number} {section_title}"
        
        st.subheader(f"üìù Generating: {section_key}")
        st.caption(f"Unit {current_section['unit_number']}: {unit_title}")
        
        with st.spinner(f"ü§ñ AI is writing content for '{section_title}'..."):
            system_prompt = """You are an experienced academic content developer specializing in postgraduate business education (MBA programs). Your writing must be comprehensive, academically rigorous, clear, and engaging.

You will write the content for ONE specific section of a study unit. Adhere strictly to the provided context. The content should reflect the depth for a 3-credit course and foster higher-order cognitive skills (analysis, evaluation) as per Bloom's Taxonomy.

PRODUCE ONLY THE BODY TEXT for the section. Do not add the section title as a heading."""

            user_prompt = f"""**Course Context:**
- Course Title: '{st.session_state.course_title}'
- Target Audience: {st.session_state.target_audience}

**Current Task:**
Write the full body content for the following section:
- Unit: '{unit_title}'
- Section: '{section_key}'
- Key Concepts to Cover: '{description}'

**Specific Instructions:**
1. **Tone and Style:** Maintain a formal, academic tone. Use clear, precise language.
   - If this is an 'Introduction' section, start with an engaging hook or relatable case study.
   
2. **Content Depth:** Elaborate on all key concepts in detail. Provide definitions, explain theories, and use relevant examples from the business world.

3. **Mandatory Structure:**
   - If this is a main content section (titles containing 'Meaning', 'Concept', 'Historical', 'Approaches'), you MUST include a 'Check Your Progress' block formatted exactly like this:
     --- CHECK YOUR PROGRESS ---
     1. Question one about the content?
     2. Question two about the content?
     -------------------------
   
   - If the section title is 'Objectives', format content as bulleted learning outcomes (e.g., "* Understand the meaning...", "* Explain the historical...").
   
   - If the section title is 'Let Us Sum Up', provide a concise summary of key takeaways from the entire unit.
   
   - If the section title is 'Unit End Activities', provide 2-3 discussion questions or short-answer problems for critical thinking.

4. **Word Count:** Generate substantial text (aim for 400-600 words) to contribute to the overall 150-page document goal.

Generate the content for section '{section_key}' now."""

            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
            
            generated_text = make_api_call(messages)
            
            if generated_text:
                st.session_state.content[section_key] = generated_text
                st.success(f"‚úÖ Section '{section_title}' completed!")
                time.sleep(1)  # Brief pause before rerun
                st.rerun()
            else:
                st.error(f"‚ùå Failed to generate content for section: {section_key}")
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("üîÑ Retry", use_container_width=True):
                        st.rerun()
                with col2:
                    if st.button("‚è≠Ô∏è Skip to Next Section", use_container_width=True):
                        st.session_state.content[section_key] = f"[Content generation failed for {section_key}]"
                        st.rerun()
    
    else:
        st.success("üéâ All content has been generated successfully!")
        st.info("üìñ Review the content below. You can make final edits before compilation.")
        
        # Display all generated content with edit capability
        for unit in st.session_state.approved_outline:
            with st.expander(f"üìö UNIT {unit['unit_number']}: {unit['unit_title']}", expanded=False):
                for section in unit.get('sections', []):
                    section_key = f"{section['section_number']} {section['section_title']}"
                    if section_key in st.session_state.content:
                        st.markdown(f"**{section_key}**")
                        edited_content = st.text_area(
                            f"Content for {section_key}",
                            st.session_state.content[section_key],
                            height=250,
                            key=f"edit_{section_key}",
                            label_visibility="collapsed"
                        )
                        st.session_state.content[section_key] = edited_content
                        st.divider()
        
        st.divider()
        
        col1, col2 = st.columns([1, 3])
        with col1:
            if st.button("üìÑ Compile Final PDF", type="primary", use_container_width=True):
                st.session_state.step = "compilation"
                st.rerun()
        with col2:
            if st.button("‚Üê Back to Outline"):
                if st.checkbox("‚ö†Ô∏è Confirm: This will discard generated content"):
                    del st.session_state.content
                    del st.session_state.sections_to_process
                    st.session_state.step = "outline_generation"
                    st.rerun()

def show_compilation_page():
    """Step 4: Compile and download PDF."""
    st.header("üìÑ Step 4: Compile and Download PDF")
    
    with st.spinner("‚öôÔ∏è Generating your professional PDF... Please wait."):
        pdf_file = compile_pdf(
            st.session_state.course_title,
            st.session_state.content,
            st.session_state.approved_outline
        )
    
    if pdf_file and os.path.exists(pdf_file):
        st.success("‚úÖ PDF compiled successfully!")
        
        with open(pdf_file, "rb") as f:
            pdf_bytes = f.read()
        
        file_size = len(pdf_bytes) / 1024  # Size in KB
        st.info(f"üìä PDF Size: {file_size:.2f} KB")
        
        col1, col2 = st.columns([1, 1])
        with col1:
            st.download_button(
                label="üì• Download PDF",
                data=pdf_bytes,
                file_name=f"{st.session_state.course_title.replace(' ', '_')}.pdf",
                mime="application/pdf",
                use_container_width=True
            )
        with col2:
            if st.button("üîÑ Start New Project", use_container_width=True):
                # Clear all session state except API key
                api_key = st.session_state.get('api_key')
                for key in list(st.session_state.keys()):
                    del st.session_state[key]
                if api_key:
                    st.session_state.api_key = api_key
                st.rerun()
    else:
        st.error("‚ùå PDF compilation failed. Please check the error messages above.")
        if st.button("‚Üê Back to Content"):
            st.session_state.step = "content_generation"
            st.rerun()

# --- Main App Logic ---
def main():
    """Main application entry point."""
    st.set_page_config(
        page_title="AI Curriculum Generator",
        page_icon="üéì",
        layout="wide",
        initial_sidebar_state="collapsed"
    )
    
    st.title("üéì AI Curriculum Generator")
    st.markdown("""
    An automated tool to generate comprehensive academic study material from a simple prompt,
    meticulously following a standard academic format suitable for MBA and postgraduate courses.
    """)
    
    # Initialize session state
    if 'step' not in st.session_state:
        st.session_state.step = "configuration"
    
    if 'api_key' not in st.session_state:
        st.session_state.api_key = DEFAULT_API_KEY
    
    # Step navigation sidebar
    with st.sidebar:
        st.header("üìç Navigation")
        steps = {
            "configuration": "1Ô∏è‚É£ Configuration",
            "outline_generation": "2Ô∏è‚É£ Outline",
            "content_generation": "3Ô∏è‚É£ Content Generation",
            "compilation": "4Ô∏è‚É£ PDF Compilation"
        }
        
        current_step = st.session_state.step
        for step_key, step_name in steps.items():
            if step_key == current_step:
                st.markdown(f"**‚Üí {step_name}**")
            else:
                st.markdown(f"„ÄÄ„ÄÄ{step_name}")
        
        st.divider()
        
        # API Status indicator
        if st.session_state.get('api_key'):
            st.success("üîë API Key Set")
        else:
            st.warning("‚ö†Ô∏è No API Key")
        
        st.divider()
        st.caption("üí° Tips: Each step builds on the previous one. Complete them in order.")
    
    # Route to appropriate page based on step
    if st.session_state.step == "configuration":
        show_configuration_page()
    elif st.session_state.step == "outline_generation":
        show_outline_page()
    elif st.session_state.step == "content_generation":
        show_content_generation_page()
    elif st.session_state.step == "compilation":
        show_compilation_page()

if __name__ == "__main__":
    main()
