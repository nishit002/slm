"""
AI CURRICULUM GENERATOR - FRESH COPY
====================================
Complete working version without any syntax errors.

Save this as: app.py
Run with: streamlit run app.py
"""

import streamlit as st
import requests
import json
import subprocess
import time
import os
import re
from datetime import datetime

# --- Configuration ---
DEFAULT_API_KEY = "xai-6QJwG3u6540lVZyXbFBArvLQ43ZyJsrnq65pyCWhxh5zXqNvtwe6LdTURbTwvE2sA3Uxlb9gn82Vamgu"
API_URL = "https://api.x.ai/v1/chat/completions"

# --- LaTeX Template ---
LATEX_TEMPLATE = r"""
\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{tocbibind}
\usepackage{titlesec}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{float}
\usepackage{caption}

\geometry{a4paper, margin=1in, top=1.25in, bottom=1.25in}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Academic Study Material},
    pdfpagemode=FullScreen,
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textit{\nouppercase{\leftmark}}}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\titleformat{\chapter}[display]
  {\normalfont\Large\bfseries\centering}
  {\MakeUppercase{\chaptertitlename} \thechapter}{10pt}{\Large\MakeUppercase}
\titlespacing*{\chapter}{0pt}{-20pt}{30pt}

\titleformat{\section}
  {\normalfont\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\normalsize\bfseries}{\thesubsection}{1em}{}

\captionsetup{font=small, labelfont=bf, justification=centering}

\usepackage{setspace}
\onehalfspacing

\begin{document}

\begin{titlepage}
\centering
\vspace*{2cm}
{\LARGE\bfseries %(course_title)s\par}
\vspace{1.5cm}
{\Large Academic Study Material\par}
\vspace{1cm}
{\large For %(target_audience)s\par}
\vspace{2cm}
\vfill
{\large Generated by AI Curriculum Generator\par}
{\large \today\par}
\end{titlepage}

\tableofcontents
\clearpage

%(list_of_figures)s

%(content)s

\end{document}
"""

# --- Helper Functions ---

def get_api_headers():
    """Get API headers with current API key."""
    api_key = st.session_state.get('api_key', DEFAULT_API_KEY)
    return {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }

def make_api_call(messages, retries=3, delay=5):
    """Makes API call with retry logic and multiple model fallback."""
    headers = get_api_headers()
    
    # Check if user specified a custom model
    if st.session_state.get('custom_model') and st.session_state.get('custom_model', '').strip():
        models_to_try = [st.session_state.custom_model]
        st.info(f"üéØ Using your custom model: {st.session_state.custom_model}")
    else:
        # Updated model names based on X.AI documentation
        models_to_try = [
            "grok-2-1212",        # Grok 2 (December 2024)
            "grok-2-latest",      # Latest Grok 2
            "grok-2",             # Grok 2 base
            "grok-beta",          # Beta version
            "grok-1",             # Grok 1
        ]
    
    last_error = None
    
    for model_name in models_to_try:
        payload = {
            "messages": messages,
            "model": model_name,
            "stream": False,
            "temperature": 0.3
        }
        
        for attempt in range(retries):
            try:
                response = requests.post(API_URL, headers=headers, json=payload, timeout=300)
                response.raise_for_status()
                # Success! Show which model worked
                if attempt == 0:
                    st.success(f"‚úÖ Connected successfully using: **{model_name}**")
                return response.json()['choices'][0]['message']['content']
                
            except requests.exceptions.HTTPError as e:
                last_error = f"{e.response.status_code}: {e.response.text if hasattr(e.response, 'text') else str(e)}"
                
                if e.response.status_code == 404:
                    # Model not found, try next one
                    if attempt == 0:  # Only show on first attempt for each model
                        st.warning(f"‚ö†Ô∏è Model '{model_name}' not found (404), trying next model...")
                    break  # Move to next model immediately
                    
                elif e.response.status_code == 403:
                    st.warning(f"‚ö†Ô∏è Access forbidden for '{model_name}', trying next model...")
                    break
                    
                elif e.response.status_code == 401:
                    st.error("‚ùå Invalid API Key! Please check your key at https://console.x.ai/")
                    return None
                    
                elif e.response.status_code == 429:
                    st.warning(f"‚è≥ Rate limit hit, waiting {delay} seconds...")
                    time.sleep(delay)
                    
                else:
                    st.warning(f"‚ö†Ô∏è HTTP {e.response.status_code} with {model_name} (attempt {attempt+1}/{retries})")
                    time.sleep(delay)
                    
            except requests.exceptions.Timeout:
                st.warning(f"‚è±Ô∏è Timeout with {model_name} (attempt {attempt+1}/{retries})")
                time.sleep(delay)
                
            except Exception as e:
                last_error = str(e)
                st.warning(f"‚ö†Ô∏è Error with {model_name}: {e}")
                time.sleep(delay)
    
    # All models failed
    st.error("‚ùå **API Connection Failed - All Models Unavailable**")
    st.error(f"Last error: {last_error}")
    
    with st.expander("üîß Troubleshooting Guide", expanded=True):
        st.markdown("""
        ### ‚úÖ Your API Key is Valid!
        
        The 404 error means your API key works, but the model names are incorrect.
        
        ### üîç Find Your Available Models:
        
        **Option 1: Check X.AI Documentation**
        - Visit: https://docs.x.ai/docs/models
        - Find the correct model name for your account
        
        **Option 2: Test with curl**
        ```bash
        curl https://api.x.ai/v1/models \\
          -H "Authorization: Bearer YOUR_API_KEY"
        ```
        
        **Option 3: Common Model Names**
        Try these model names manually:
        - `grok-2-1212`
        - `grok-2-latest`
        - `grok-vision-beta`
        - `grok-beta`
        
        ### üìù How to Add a Custom Model:
        
        If you find a working model name, let me know and I'll add it!
        
        ### üÜò Need Help?
        - X.AI Support: https://x.ai/support
        - API Status: https://status.x.ai/
        - Documentation: https://docs.x.ai/
        """)
    
    return None

def escape_latex(text):
    """Escapes special LaTeX characters."""
    if not text:
        return ""
    text = str(text)
    text = text.replace('\\', '\\textbackslash{}')
    text = text.replace('{', '\\{')
    text = text.replace('}', '\\}')
    text = text.replace('_', '\\_')
    text = text.replace('#', '\\#')
    text = text.replace('%', '\\%')
    text = text.replace('&', '\\&')
    text = text.replace('$', '\\$')
    text = text.replace('~', '\\textasciitilde{}')
    text = text.replace('^', '\\textasciicircum{}')
    return text

def markdown_to_latex(md_text):
    """Converts markdown to LaTeX."""
    if not md_text:
        return ""
    
    # Check Your Progress blocks
    md_text = re.sub(
        r'---\s*CHECK YOUR PROGRESS\s*---(.*?)---+',
        r'\n\\begin{center}\n\\fbox{\\begin{minipage}{0.9\\textwidth}\n\\textbf{CHECK YOUR PROGRESS}\n\\begin{enumerate}\1\\end{enumerate}\n\\end{minipage}}\n\\end{center}\n',
        md_text,
        flags=re.DOTALL | re.IGNORECASE
    )
    
    # Figure placeholders
    md_text = re.sub(
        r'\[\[FIGURE\s+(\d+):\s*(.*?)\]\]',
        r'\n\\begin{figure}[H]\n\\centering\n\\includegraphics[width=0.7\\textwidth]{figure_\1.png}\n\\caption{\2}\n\\label{fig:\1}\n\\end{figure}\n',
        md_text,
        flags=re.IGNORECASE
    )
    
    # Headers
    md_text = re.sub(r'^# UNIT (\d+):\s*(.*)$', r'\\chapter{\2}', md_text, flags=re.MULTILINE)
    md_text = re.sub(r'^##\s*(\d+\.\d+)\s+(.*)$', r'\\section{\2}', md_text, flags=re.MULTILINE)
    md_text = re.sub(r'^###\s+(.*)$', r'\\subsection{\1}', md_text, flags=re.MULTILINE)
    
    # Bold and Italic
    md_text = re.sub(r'\*\*(.*?)\*\*', r'\\textbf{\1}', md_text)
    md_text = re.sub(r'\*(.*?)\*', r'\\textit{\1}', md_text)
    
    # Lists
    lines = md_text.split('\n')
    result = []
    in_list = False
    
    for line in lines:
        if re.match(r'^\s*[-*]\s+', line):
            if not in_list:
                result.append('\\begin{itemize}')
                in_list = True
            item = re.sub(r'^\s*[-*]\s+', '', line)
            result.append(f'\\item {item}')
        else:
            if in_list:
                result.append('\\end{itemize}')
                in_list = False
            result.append(line)
    
    if in_list:
        result.append('\\end{itemize}')
    
    md_text = '\n'.join(result)
    return escape_latex(md_text)

def compile_pdf(course_title, content_dict, outline, target_audience="Postgraduate", uploaded_images=None):
    """Compiles PDF using pdflatex."""
    st.info("Assembling document...")
    
    # Save images
    has_figures = False
    if uploaded_images:
        for fig_num, img_file in uploaded_images.items():
            if img_file:
                has_figures = True
                with open(f"figure_{fig_num}.png", "wb") as f:
                    f.write(img_file.getvalue())
    
    # Assemble content
    full_content = ""
    for unit in outline:
        unit_num = unit.get('unit_number', 1)
        unit_title = unit.get('unit_title', 'Untitled')
        full_content += f"# UNIT {unit_num}: {unit_title}\n\n"
        
        for section in unit.get('sections', []):
            sec_num = section.get('section_number', '1.1')
            sec_title = section.get('section_title', 'Untitled')
            sec_key = f"{sec_num} {sec_title}"
            full_content += f"## {sec_key}\n\n"
            full_content += content_dict.get(sec_key, "Content not generated.") + "\n\n"
    
    st.info("Converting to LaTeX...")
    latex_content = markdown_to_latex(full_content)
    
    list_of_figs = "\\listoffigures\n\\clearpage\n" if has_figures else ""
    
    final_doc = LATEX_TEMPLATE % {
        'course_title': escape_latex(course_title),
        'target_audience': escape_latex(target_audience),
        'list_of_figures': list_of_figs,
        'content': latex_content
    }
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"curriculum_{timestamp}"
    
    with open(f"{filename}.tex", "w", encoding='utf-8') as f:
        f.write(final_doc)
    
    st.info("Compiling PDF...")
    try:
        for i in range(3):
            subprocess.run(['pdflatex', '-interaction=nonstopmode', f'{filename}.tex'],
                         check=True, capture_output=True, timeout=120)
        st.success("PDF compiled!")
        return f"{filename}.pdf"
    except Exception as e:
        st.error(f"Compilation failed: {e}")
        return None

# --- UI Functions ---

def show_configuration_page():
    """Step 1: Configuration."""
    st.header("Step 1: Configure Your Course")
    
    st.subheader("API Configuration")
    
    # Manual model selection option
    col1, col2 = st.columns([2, 1])
    with col1:
        use_custom_model = st.checkbox("üîß Use Custom Model Name", 
                                       help="If you know your exact model name, enter it here")
    with col2:
        if use_custom_model:
            custom_model = st.text_input("Model Name", 
                                        value=st.session_state.get('custom_model', 'grok-2-1212'),
                                        help="e.g., grok-2-1212, grok-vision-beta")
            st.session_state.custom_model = custom_model
    
    col1, col2 = st.columns([3, 1])
    with col1:
        api_key = st.text_input("Grok API Key", value=st.session_state.get('api_key', DEFAULT_API_KEY),
                                type="password", key="api_key_input",
                                help="Get your API key from https://console.x.ai/")
        st.session_state.api_key = api_key
        
        # Show API key status
        if api_key:
            if api_key.startswith('xai-') and len(api_key) > 20:
                st.success("‚úÖ API key format looks valid")
            else:
                st.warning("‚ö†Ô∏è API key format may be incorrect. Should start with 'xai-'")
        
    with col2:
        if st.button("Test API", use_container_width=True):
            with st.spinner("Testing API..."):
                # Use custom model if specified
                if use_custom_model and st.session_state.get('custom_model'):
                    # Test with specific model
                    test_headers = get_api_headers()
                    test_payload = {
                        "messages": [{"role": "user", "content": "Say: Working"}],
                        "model": st.session_state.custom_model,
                        "stream": False
                    }
                    try:
                        resp = requests.post(API_URL, headers=test_headers, json=test_payload, timeout=30)
                        resp.raise_for_status()
                        st.success(f"‚úÖ Model '{st.session_state.custom_model}' working!")
                        st.balloons()
                    except Exception as e:
                        st.error(f"‚ùå Model test failed: {e}")
                else:
                    # Test with automatic model selection
                    test_messages = [{"role": "user", "content": "Reply with: OK"}]
                    resp = make_api_call(test_messages)
                    if resp:
                        st.success("‚úÖ API Working!")
                        st.balloons()
                    else:
                        st.error("‚ùå API Test Failed")
    
    st.divider()
    st.subheader("Course Details")
    
    # Add API diagnostics
    with st.expander("üîç API Diagnostics", expanded=False):
        st.markdown("**Current API Configuration:**")
        st.code(f"URL: {API_URL}\nModel: Trying multiple models (grok-beta, grok-2-1212, etc.)")
        
        if st.button("üî¨ Detailed API Test"):
            api_key = st.session_state.get('api_key', DEFAULT_API_KEY)
            st.info(f"Testing with API key: {api_key[:10]}...{api_key[-4:]}")
            
            # Test with minimal payload
            test_headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}"
            }
            test_payload = {
                "messages": [{"role": "user", "content": "Hi"}],
                "model": "grok-beta",
                "stream": False,
                "temperature": 0
            }
            
            try:
                response = requests.post(API_URL, headers=test_headers, json=test_payload, timeout=30)
                st.write(f"**Status Code:** {response.status_code}")
                st.write(f"**Response Headers:**")
                st.json(dict(response.headers))
                
                if response.status_code == 200:
                    st.success("‚úÖ API is working correctly!")
                    st.json(response.json())
                else:
                    st.error(f"‚ùå Error: {response.status_code}")
                    st.code(response.text)
                    
                    if response.status_code == 403:
                        st.warning("""
                        **403 Forbidden - Possible Causes:**
                        1. ‚ùå Invalid API key
                        2. ‚ùå API key expired
                        3. ‚ùå Account has no credits
                        4. ‚ùå Model access restricted
                        
                        **Solutions:**
                        - Generate a new API key at https://console.x.ai/
                        - Check your account balance
                        - Verify API key permissions
                        """)
            except Exception as e:
                st.error(f"Request failed: {e}")
    
    st.divider()
    
    st.text_input("Course Title", "Organisational Behaviour: Concept, Nature & Historical Perspectives", key="course_title")
    st.selectbox("Target Audience", ["Postgraduate (MBA)", "University Undergraduate", "Professional Development"], key="target_audience")
    st.text_area("Learning Objectives", "Develop comprehensive content for a 3-credit MBA course...", key="learning_objectives", height=150)
    
    st.divider()
    if st.button("Generate Course Outline", type="primary"):
        if st.session_state.get('api_key'):
            st.session_state.step = "outline_generation"
            st.rerun()
        else:
            st.error("Please enter API key first!")

def show_outline_page():
    """Step 2: Outline."""
    st.header("Step 2: Review Course Outline")
    
    if 'outline' not in st.session_state:
        with st.spinner("Generating outline..."):
            system_prompt = """Create a JSON array of units with sections. Each unit needs: unit_number, unit_title, sections array. Each section needs: section_number, section_title, description. First two sections must be Introduction and Objectives. Last two must be Let Us Sum Up and Unit End Activities. Output only JSON."""
            
            user_prompt = f"Course: {st.session_state.course_title}\nAudience: {st.session_state.target_audience}\nCreate 4-6 units with 6-10 sections each."
            
            messages = [{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}]
            outline_str = make_api_call(messages)
            
            if outline_str:
                try:
                    json_match = re.search(r'```(?:json)?\s*\n(.*?)\n```', outline_str, re.DOTALL)
                    if json_match:
                        outline_str = json_match.group(1)
                    st.session_state.outline = json.loads(outline_str.strip())
                except:
                    st.error("Failed to parse outline")
                    st.session_state.outline = [{"unit_number": 1, "unit_title": "Unit 1", "sections": [
                        {"section_number": "1.1", "section_title": "Introduction", "description": "Overview"}
                    ]}]
    
    if 'outline' in st.session_state:
        rows = []
        for unit in st.session_state.outline:
            for section in unit.get('sections', []):
                rows.append({
                    'unit_number': unit['unit_number'],
                    'unit_title': unit['unit_title'],
                    'section_number': section['section_number'],
                    'section_title': section['section_title'],
                    'description': section['description']
                })
        
        edited = st.data_editor(rows, num_rows="dynamic", use_container_width=True, height=500)
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Units", len(set(r['unit_number'] for r in edited)))
        with col2:
            st.metric("Sections", len(edited))
        with col3:
            avg = len(edited) / len(set(r['unit_number'] for r in edited))
            st.metric("Avg/Unit", f"{avg:.1f}")
        
        st.divider()
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Approve & Begin Writing", type="primary", use_container_width=True):
                approved = []
                current = None
                for row in edited:
                    if current is None or current['unit_number'] != row['unit_number']:
                        if current:
                            approved.append(current)
                        current = {'unit_number': row['unit_number'], 'unit_title': row['unit_title'], 'sections': []}
                    current['sections'].append({
                        'section_number': row['section_number'],
                        'section_title': row['section_title'],
                        'description': row['description']
                    })
                if current:
                    approved.append(current)
                st.session_state.approved_outline = approved
                st.session_state.step = "content_generation"
                st.rerun()
        with col2:
            if st.button("Back", use_container_width=True):
                del st.session_state.outline
                st.session_state.step = "configuration"
                st.rerun()

def show_content_generation_page():
    """Step 3: Content Generation with LIVE PREVIEW."""
    st.header("Step 3: Content Generation with Live Preview")
    
    if 'approved_outline' not in st.session_state:
        st.error("No outline found")
        if st.button("Go to Configuration"):
            st.session_state.step = "configuration"
            st.rerun()
        return
    
    if 'content' not in st.session_state:
        st.session_state.content = {}
        st.session_state.sections_to_process = []
        for unit in st.session_state.approved_outline:
            for section in unit.get('sections', []):
                st.session_state.sections_to_process.append({
                    'unit_number': unit['unit_number'],
                    'unit_title': unit['unit_title'],
                    'section_number': section['section_number'],
                    'section_title': section['section_title'],
                    'description': section.get('description', '')
                })
    
    total = len(st.session_state.sections_to_process)
    completed = len(st.session_state.content)
    
    # ===== LIVE PREVIEW SECTION =====
    st.markdown("---")
    st.markdown("### üìñ LIVE DOCUMENT PREVIEW (Updates in Real-Time)")
    st.caption("üëá This is how your PDF will look. Content appears here as it's generated.")
    
    # Create a scrollable preview container
    preview_container = st.container()
    
    with preview_container:
        # Show document title
        st.markdown(f"# üéì {st.session_state.get('course_title', 'Course Title')}")
        st.markdown(f"**For:** {st.session_state.get('target_audience', 'Students')}")
        st.markdown("---")
        
        # Show generated content so far
        if st.session_state.content:
            for unit in st.session_state.approved_outline:
                unit_has_content = False
                
                # Check if this unit has any content
                for section in unit.get('sections', []):
                    sec_key = f"{section['section_number']} {section['section_title']}"
                    if sec_key in st.session_state.content:
                        unit_has_content = True
                        break
                
                # Only show unit if it has content
                if unit_has_content:
                    st.markdown(f"## UNIT {unit['unit_number']}: {unit['unit_title']}")
                    st.markdown("---")
                    
                    for section in unit.get('sections', []):
                        sec_key = f"{section['section_number']} {section['section_title']}"
                        
                        if sec_key in st.session_state.content:
                            # Show section header
                            st.markdown(f"### {sec_key}")
                            
                            # Show content with proper formatting
                            content = st.session_state.content[sec_key]
                            
                            # Format Check Your Progress boxes
                            if "CHECK YOUR PROGRESS" in content.upper():
                                parts = re.split(r'---\s*CHECK YOUR PROGRESS\s*---', content, flags=re.IGNORECASE)
                                if len(parts) > 1:
                                    st.markdown(parts[0])
                                    st.info("**üìù CHECK YOUR PROGRESS**\n\n" + parts[1].replace('---', '').strip())
                            else:
                                st.markdown(content)
                            
                            # Show figure placeholders
                            figures = re.findall(r'\[\[FIGURE\s+(\d+):\s*(.*?)\]\]', content, re.IGNORECASE)
                            for fig_num, fig_desc in figures:
                                st.image("https://via.placeholder.com/600x400/cccccc/000000?text=Figure+" + fig_num, 
                                        caption=f"Figure {fig_num}: {fig_desc}", 
                                        use_container_width=True)
                            
                            st.markdown("---")
        
        # Show what's being generated now
        if completed < total:
            current = st.session_state.sections_to_process[completed]
            st.markdown(f"### ‚è≥ {current['section_number']} {current['section_title']}")
            st.info("ü§ñ Currently generating...")
    
    st.markdown("---")
    
    # ===== GENERATION CONTROL SECTION =====
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("‚úÖ Completed", f"{completed}/{total}")
    with col2:
        st.metric("‚è≥ Remaining", f"{total - completed}")
    with col3:
        progress_pct = (completed / total * 100) if total > 0 else 0
        st.metric("üìä Progress", f"{progress_pct:.1f}%")
    
    st.progress(completed / total if total > 0 else 0)
    
    # ===== AUTO-GENERATION SECTION =====
    if completed < total:
        current = st.session_state.sections_to_process[completed]
        section_key = f"{current['section_number']} {current['section_title']}"
        
        st.markdown("---")
        st.markdown(f"### ü§ñ Now Generating: {section_key}")
        
        col1, col2 = st.columns([3, 1])
        with col1:
            st.info(f"**Unit:** {current['unit_title']}\n\n**Topics:** {current['description']}")
        with col2:
            # Manual controls
            if st.button("‚è∏Ô∏è Pause & Review", use_container_width=True):
                st.session_state.paused = True
                st.info("‚è∏Ô∏è Paused. Review content above before continuing.")
                st.stop()
        
        # Check if paused
        if not st.session_state.get('paused', False):
            with st.spinner(f"‚úçÔ∏è AI is writing '{current['section_title']}'... (30-60 seconds)"):
                # Generate content
                system_prompt = """You are an expert academic content writer for MBA programs. 

**CRITICAL FORMATTING RULES:**
1. Use clear paragraph breaks (double newline)
2. Use bullet points with asterisks (*) for lists
3. Use numbering (1., 2., 3.) for sequential points
4. Include figure placeholders as: [[FIGURE X: description]]
5. For Check Your Progress: Format exactly as:
   --- CHECK YOUR PROGRESS ---
   1. Question one?
   2. Question two?
   ---

Write comprehensive, professional academic content."""
                
                user_prompt = f"""**Section:** {section_key}
**Unit:** {current['unit_title']}
**Topics to Cover:** {current['description']}
**Audience:** {st.session_state.get('target_audience', 'MBA students')}

Write 500-700 words of detailed academic content. Include:
- Clear introduction
- Well-explained concepts with examples
- Proper academic tone
- If content section: Add "Check Your Progress" with 2-3 questions
- If suitable: Add [[FIGURE X: description]] placeholders for diagrams"""
                
                messages = [{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}]
                content = make_api_call(messages)
                
                if content:
                    st.session_state.content[section_key] = content
                    st.success(f"‚úÖ Completed: {section_key}")
                    
                    # Show preview of what was just generated
                    with st.expander("üìÑ Just Generated - Review Now", expanded=True):
                        st.markdown(f"#### {section_key}")
                        st.markdown(content)
                        st.caption(f"üìä {len(content.split())} words | {len(content)} characters")
                        
                        # Quick edit option
                        if st.checkbox(f"‚úèÔ∏è Edit this section before continuing", key=f"quick_edit_{section_key}"):
                            edited = st.text_area("Edit content:", content, height=300, key=f"edit_now_{section_key}")
                            if st.button("üíæ Save Changes", key=f"save_{section_key}"):
                                st.session_state.content[section_key] = edited
                                st.success("Saved!")
                                time.sleep(1)
                                st.rerun()
                    
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error(f"‚ùå Failed to generate: {section_key}")
                    
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        if st.button("üîÑ Retry", use_container_width=True):
                            st.rerun()
                    with col2:
                        if st.button("‚úèÔ∏è Write Manually", use_container_width=True):
                            manual_content = st.text_area("Write content manually:", height=400)
                            if st.button("üíæ Save Manual Content"):
                                st.session_state.content[section_key] = manual_content
                                st.success("Saved!")
                                st.rerun()
                    with col3:
                        if st.button("‚è≠Ô∏è Skip", use_container_width=True):
                            st.session_state.content[section_key] = f"[Skipped - {section_key}]\n\nPlease add content manually."
                            st.rerun()
        else:
            # Paused state
            st.warning("‚è∏Ô∏è Generation Paused - Review the content above")
            if st.button("‚ñ∂Ô∏è Continue Generation", type="primary", use_container_width=True):
                st.session_state.paused = False
                st.rerun()
    
    else:
        # All content generated
        st.success("üéâ All content generated successfully!")
        
        # Final statistics
        st.markdown("---")
        st.markdown("### üìä Document Statistics")
        
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üìÑ Total Sections", total)
        with col2:
            total_words = sum(len(c.split()) for c in st.session_state.content.values())
            st.metric("üìù Total Words", f"{total_words:,}")
        with col3:
            total_chars = sum(len(c) for c in st.session_state.content.values())
            pages_estimate = total_chars / 3000  # ~3000 chars per page
            st.metric("üìñ Est. Pages", f"{pages_estimate:.0f}")
        with col4:
            fig_count = len(set(re.findall(r'\[\[FIGURE\s+(\d+):', ' '.join(st.session_state.content.values()), re.IGNORECASE)))
            st.metric("üñºÔ∏è Figures", fig_count)
        
        st.markdown("---")
        
        # Show figure prompts
        fig_nums = set()
        fig_descs = {}
        for content in st.session_state.content.values():
            figs = re.findall(r'\[\[FIGURE\s+(\d+):\s*(.*?)\]\]', content, re.IGNORECASE)
            for num, desc in figs:
                num = int(num)
                fig_nums.add(num)
                if num not in fig_descs:
                    fig_descs[num] = desc
        
        if fig_nums:
            with st.expander(f"üé® Image Generation Prompts ({len(fig_nums)} figures)", expanded=True):
                st.markdown("### Copy these prompts to generate images with AI tools")
                for num in sorted(fig_nums):
                    desc = fig_descs.get(num, "")
                    col1, col2 = st.columns([1, 4])
                    with col1:
                        st.markdown(f"**Figure {num}**")
                    with col2:
                        prompt = f"Professional academic diagram for business textbook: {desc}. Style: clean, minimalist, educational, high contrast, clear labels, white background, vector-style."
                        st.code(prompt, language="text")
        
        st.markdown("---")
        
        # Quick content review section
        with st.expander("üìù Quick Content Review - Edit Any Section", expanded=False):
            for unit in st.session_state.approved_outline:
                st.markdown(f"### UNIT {unit['unit_number']}: {unit['unit_title']}")
                for section in unit.get('sections', []):
                    sec_key = f"{section['section_number']} {section['section_title']}"
                    if sec_key in st.session_state.content:
                        with st.expander(f"Edit: {sec_key}"):
                            edited = st.text_area(
                                "Content:",
                                st.session_state.content[sec_key],
                                height=300,
                                key=f"final_edit_{sec_key}"
                            )
                            if st.button(f"üíæ Update {sec_key}", key=f"update_{sec_key}"):
                                st.session_state.content[sec_key] = edited
                                st.success("‚úÖ Updated!")
        
        st.markdown("---")
        
        # Navigation
        col1, col2, col3 = st.columns([1, 1, 2])
        with col1:
            if st.button("üñºÔ∏è Add Images & Compile PDF", type="primary", use_container_width=True):
                st.session_state.step = "image_upload"
                st.rerun()
        with col2:
            if st.button("‚Üê Back to Outline", use_container_width=True):
                if st.checkbox("‚ö†Ô∏è Discard all content?"):
                    del st.session_state.content
                    st.session_state.step = "outline_generation"
                    st.rerun()
        with col3:
            st.caption("üí° Review the live preview above before proceeding")
        current = st.session_state.sections_to_process[completed]
        section_key = f"{current['section_number']} {current['section_title']}"
        
        # Show current section being generated
        status_placeholder.info(f"ü§ñ **Currently Generating:** Unit {current['unit_number']} - {section_key}")
        
        # Show what's being generated in real-time
        with content_preview_placeholder.container():
            st.markdown("### üìù Generation Preview")
            st.caption(f"**Unit:** {current['unit_title']}")
            st.caption(f"**Section:** {section_key}")
            st.caption(f"**Description:** {current['description']}")
            
            # Create a progress indicator
            with st.spinner("‚úçÔ∏è AI is writing content... This may take 30-60 seconds"):
                
                # Show a simulated progress for better UX
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                for i in range(100):
                    progress_bar.progress(i + 1)
                    if i < 20:
                        status_text.text("üìñ Analyzing section requirements...")
                    elif i < 40:
                        status_text.text("üí≠ Structuring content framework...")
                    elif i < 60:
                        status_text.text("‚úçÔ∏è Writing main content...")
                    elif i < 80:
                        status_text.text("üîç Adding examples and details...")
                    else:
                        status_text.text("‚úÖ Finalizing section...")
                    time.sleep(0.03)  # Small delay for visual effect
        
        # Generate content
        system_prompt = """You are an expert academic content developer for MBA programs. Write comprehensive, rigorous content for ONE section. 

IMPORTANT: Include figure placeholders where diagrams would enhance understanding, formatted as: [[FIGURE X: description]]

Structure your content professionally with:
- Clear paragraphs
- Bullet points for lists
- Academic tone
- Real-world examples
- If applicable, a "Check Your Progress" section with questions"""
        
        user_prompt = f"""**Section to Write:** {section_key}
**Unit Context:** {current['unit_title']}
**Key Topics to Cover:** {current['description']}
**Target Audience:** {st.session_state.get('target_audience', 'MBA students')}

Write 400-600 words of comprehensive academic content. Be detailed and thorough."""
        
        messages = [{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}]
        content = make_api_call(messages)
        
        if content:
            st.session_state.content[section_key] = content
            
            # Show success with the generated content
            status_placeholder.success(f"‚úÖ **Completed:** {section_key}")
            
            with content_preview_placeholder.container():
                st.markdown("### ‚úÖ Generated Content Preview")
                with st.expander(f"View: {section_key}", expanded=True):
                    st.markdown(content[:500] + "..." if len(content) > 500 else content)
                    st.caption(f"Total length: {len(content)} characters (~{len(content.split())} words)")
            
            time.sleep(2)  # Brief pause to show the result
            st.rerun()
        else:
            status_placeholder.error(f"‚ùå **Failed:** {section_key}")
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("üîÑ Retry This Section", use_container_width=True):
                    st.rerun()
            with col2:
                if st.button("‚è≠Ô∏è Skip This Section", use_container_width=True):
                    st.session_state.content[section_key] = "[Content generation failed - please edit manually]"
                    st.rerun()
            with col3:
                if st.button("üõë Stop Generation", use_container_width=True):
                    st.session_state.step = "content_review"
                    st.rerun()
    
    else:
        status_placeholder.success("üéâ **All content generated successfully!**")
        
        # Show completion statistics
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Total Sections", total)
        with col2:
            total_words = sum(len(c.split()) for c in st.session_state.content.values())
            st.metric("Total Words", f"{total_words:,}")
        with col3:
            total_chars = sum(len(c) for c in st.session_state.content.values())
            st.metric("Total Characters", f"{total_chars:,}")
        with col4:
            # Extract figure count
            fig_count = len(set(re.findall(r'\[\[FIGURE\s+(\d+):', ' '.join(st.session_state.content.values()), re.IGNORECASE)))
            st.metric("Figures Detected", fig_count)
        
        st.divider()
        
        # Show figure prompts if any
        fig_nums = set()
        fig_descs = {}
        for content in st.session_state.content.values():
            figs = re.findall(r'\[\[FIGURE\s+(\d+):\s*(.*?)\]\]', content, re.IGNORECASE)
            for num, desc in figs:
                num = int(num)
                fig_nums.add(num)
                if num not in fig_descs:
                    fig_descs[num] = desc
        
        if fig_nums:
            st.success(f"üñºÔ∏è **{len(fig_nums)} figures detected in content**")
            with st.expander("üìã View Figure Prompts for Image Generation", expanded=True):
                st.markdown("### üé® Image Generation Prompts")
                st.caption("Use these prompts with AI image generators (DALL-E, Midjourney, Stable Diffusion)")
                
                for num in sorted(fig_nums):
                    desc = fig_descs.get(num, "No description")
                    col1, col2 = st.columns([1, 3])
                    with col1:
                        st.markdown(f"**Figure {num}:**")
                    with col2:
                        prompt = f"Professional academic diagram for business textbook: {desc}. Style: clean, professional, educational, high contrast, clear labels."
                        st.code(prompt, language="text")
        
        st.divider()
        
        # Show all content with live preview
        st.markdown("### üìö Review & Edit Generated Content")
        st.info("üí° Expand each unit below to review and edit the content before proceeding to PDF compilation")
        
        for unit in st.session_state.approved_outline:
            with st.expander(f"üìñ UNIT {unit['unit_number']}: {unit['unit_title']}", expanded=False):
                for section in unit.get('sections', []):
                    sec_key = f"{section['section_number']} {section['section_title']}"
                    if sec_key in st.session_state.content:
                        st.markdown(f"#### {sec_key}")
                        
                        # Show word count
                        word_count = len(st.session_state.content[sec_key].split())
                        st.caption(f"üìä {word_count} words | {len(st.session_state.content[sec_key])} characters")
                        
                        # Editable content
                        edited = st.text_area(
                            f"Edit content for {sec_key}",
                            st.session_state.content[sec_key],
                            height=300,
                            key=f"edit_{sec_key}",
                            label_visibility="collapsed"
                        )
                        st.session_state.content[sec_key] = edited
                        st.divider()
        
        st.divider()
        
        # Navigation buttons
        col1, col2, col3 = st.columns([1, 1, 2])
        with col1:
            if st.button("üìÑ Proceed to Image Upload", type="primary", use_container_width=True):
                st.session_state.step = "image_upload"
                st.rerun()
        with col2:
            if st.button("‚Üê Back to Outline", use_container_width=True):
                st.session_state.step = "outline_generation"
                st.rerun()
        with col3:
            st.caption("üí° Tip: Review and edit content before adding images")

def show_image_upload_page():
    """Step 3.5: Image Upload."""
    st.header("Step 3.5: Upload Images")
    
    fig_nums = set()
    fig_descs = {}
    for content in st.session_state.content.values():
        figs = re.findall(r'\[\[FIGURE\s+(\d+):\s*(.*?)\]\]', content, re.IGNORECASE)
        for num, desc in figs:
            num = int(num)
            fig_nums.add(num)
            if num not in fig_descs:
                fig_descs[num] = desc
    
    if not fig_nums:
        st.info("No figures detected")
        if st.button("Compile PDF", type="primary"):
            st.session_state.step = "compilation"
            st.rerun()
        return
    
    st.info(f"Total figures: {len(fig_nums)}")
    
    if 'uploaded_images' not in st.session_state:
        st.session_state.uploaded_images = {}
    
    for num in sorted(fig_nums):
        desc = fig_descs.get(num, "")
        col1, col2 = st.columns([3, 1])
        with col1:
            uploaded = st.file_uploader(f"Figure {num}: {desc}", type=['png', 'jpg'], key=f"fig_{num}")
            if uploaded:
                st.session_state.uploaded_images[num] = uploaded
        with col2:
            if uploaded:
                st.image(uploaded, width=150)
    
    st.divider()
    uploaded_count = len(st.session_state.uploaded_images)
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Uploaded", f"{uploaded_count}/{len(fig_nums)}")
    with col2:
        if st.button("Compile PDF", type="primary", use_container_width=True):
            st.session_state.step = "compilation"
            st.rerun()

def show_compilation_page():
    """Step 4: Compilation."""
    st.header("Step 4: Compile PDF")
    
    if 'content' not in st.session_state:
        st.error("No content found")
        return
    
    with st.spinner("Compiling PDF..."):
        pdf_file = compile_pdf(
            st.session_state.course_title,
            st.session_state.content,
            st.session_state.approved_outline,
            st.session_state.get('target_audience', 'Postgraduate'),
            st.session_state.get('uploaded_images', {})
        )
    
    if pdf_file and os.path.exists(pdf_file):
        st.success("PDF Ready!")
        with open(pdf_file, "rb") as f:
            pdf_bytes = f.read()
        
        col1, col2 = st.columns(2)
        with col1:
            st.download_button("Download PDF", pdf_bytes, 
                             file_name=f"{st.session_state.course_title.replace(' ', '_')}.pdf",
                             mime="application/pdf", use_container_width=True)
        with col2:
            if st.button("New Project", use_container_width=True):
                api_key = st.session_state.get('api_key')
                for key in list(st.session_state.keys()):
                    del st.session_state[key]
                if api_key:
                    st.session_state.api_key = api_key
                st.rerun()
    else:
        st.error("Compilation failed")

def main():
    """Main app."""
    st.set_page_config(page_title="AI Curriculum Generator", page_icon="üéì", layout="wide")
    st.title("üéì AI Curriculum Generator")
    
    if 'step' not in st.session_state:
        st.session_state.step = "configuration"
    if 'api_key' not in st.session_state:
        st.session_state.api_key = DEFAULT_API_KEY
    
    with st.sidebar:
        st.header("Navigation")
        steps = {"configuration": "1Ô∏è‚É£ Config", "outline_generation": "2Ô∏è‚É£ Outline",
                "content_generation": "3Ô∏è‚É£ Content", "image_upload": "3.5Ô∏è‚É£ Images",
                "compilation": "4Ô∏è‚É£ PDF"}
        for key, name in steps.items():
            if key == st.session_state.step:
                st.markdown(f"**‚Üí {name}**")
            else:
                st.markdown(f"„ÄÄ{name}")
    
    if st.session_state.step == "configuration":
        show_configuration_page()
    elif st.session_state.step == "outline_generation":
        show_outline_page()
    elif st.session_state.step == "content_generation":
        show_content_generation_page()
    elif st.session_state.step == "image_upload":
        show_image_upload_page()
    elif st.session_state.step == "compilation":
        show_compilation_page()

if __name__ == "__main__":
    main()
